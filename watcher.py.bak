"""
Vault Watcher Module

Monitors the Obsidian vault for changes and automatically triggers indexing updates.
Uses the watchdog library for efficient file system monitoring.
"""

import time
import threading
from pathlib import Path
from typing import Optional
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileSystemEvent

from indexer import VaultIndexer
from vector_store import VectorStore
from utils import get_relative_path

class VaultWatcher(FileSystemEventHandler):
    """
    Handles file system events for the Obsidian vault and triggers indexing updates.
    """

    def __init__(
        self,
        vault_path: Path,
        indexer: VaultIndexer,
        vector_store: VectorStore,
        debounce_seconds: float = 1.0
    ):
        self.vault_path = vault_path
        self.indexer = indexer
        self.vector_store = vector_store
        self.debounce_seconds = debounce_seconds
        
        # Keep track of last processing time to debounce rapid events
        self._last_processed = {}
        self._processing_lock = threading.Lock()
        
        self.observer = Observer()

    def start(self):
        """Start monitoring the vault in a background thread."""
        print(f"Starting Vault Watcher attached to: {self.vault_path}")
        self.observer.schedule(self, str(self.vault_path), recursive=True)
        self.observer.start()

    def stop(self):
        """Stop monitoring."""
        self.observer.stop()
        self.observer.join()

    def _should_process(self, file_path: Path) -> bool:
        """
        Check if an event should be processed (debouncing and file type check).
        """
        # Only process .md files
        if file_path.suffix != '.md':
            return False
            
        # Ignore hidden files/dirs
        if any(part.startswith('.') for part in file_path.parts):
            return False

        now = time.time()
        path_str = str(file_path)
        
        with self._processing_lock:
            last_time = self._last_processed.get(path_str, 0)
            if now - last_time < self.debounce_seconds:
                return False
            
            self._last_processed[path_str] = now
            return True

    def on_created(self, event: FileSystemEvent):
        if event.is_directory:
            return
        
        path = Path(event.src_path)
        if self._should_process(path):
            print(f"Watcher: New file detected: {path.name}")
            try:
                self.indexer.index_single_file(path)
            except Exception as e:
                print(f"Watcher Error: Failed to index created file {path}: {e}")

    def on_modified(self, event: FileSystemEvent):
        if event.is_directory:
            return

        path = Path(event.src_path)
        if self._should_process(path):
            print(f"Watcher: File modified: {path.name}")
            try:
                self.indexer.index_single_file(path)
            except Exception as e:
                print(f"Watcher Error: Failed to re-index modified file {path}: {e}")

    def on_deleted(self, event: FileSystemEvent):
        if event.is_directory:
            return

        path = Path(event.src_path)
        # No debounce needed for deletion usually, but we check extension
        if path.suffix != '.md':
            return

        print(f"Watcher: File deleted: {path.name}")
        try:
            relative_path = get_relative_path(path, self.vault_path)
            self.vector_store.delete_by_file_path(relative_path)
        except Exception as e:
            print(f"Watcher Error: Failed to delete embeddings for {path}: {e}")

    def on_moved(self, event: FileSystemEvent):
        if event.is_directory:
            return

        src_path = Path(event.src_path)
        dest_path = Path(event.dest_path)

        if src_path.suffix == '.md':
             print(f"Watcher: File moved from {src_path.name} to {dest_path.name}")
             try:
                # 1. Delete old
                rel_src = get_relative_path(src_path, self.vault_path)
                self.vector_store.delete_by_file_path(rel_src)
                
                # 2. Index new (if it's still markdown and valid)
                if self._should_process(dest_path):
                    self.indexer.index_single_file(dest_path)
             except Exception as e:
                 print(f"Watcher Error: Failed to handle move {src_path} -> {dest_path}: {e}")
